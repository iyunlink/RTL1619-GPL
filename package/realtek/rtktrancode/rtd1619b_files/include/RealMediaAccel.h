/*
 * Copyright (C) 2002-2021 Realtek Semiconductor Corp.
 *
  * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 2.1 as
 * published by the Free Software Foundation.
 *
 */
#ifndef __RTKMEDIAACCEL_H__
#define __RTKMEDIAACCEL_H__

/**
 * @file rtkMediaAccel.h
 * @brief libRMA API Header File
 */

/**
 * RMA API Return Values
 */
typedef enum {
    RMA_SUCCESS = 0,                    /**< Success */
    RMA_ERR_FAILURE = -1,               /**< Generic error */
    RMA_ERR_INVALID_OPERATION = -2,     /**< Invalid operation */
    RMA_ERR_INVALID_PARAM = -3,         /**< Invalid parameters */
    RMA_ERR_INSUFFICIENT_RESOURCE = -4, /**< Insufficient HW resource */
    RMA_ERR_AGAIN = -5,                 /**< Polling fail, retry */
    RMA_ERR_DECODER_NOT_FOUND = -6,     /**< HW Decoder isn't found */
    RMA_ERR_NOT_SUPPORT = -7,           /**< Unsupport feature */
} RMA_ERRORTYPE;

/**
 * Type of Enqueued data
 */
typedef enum {
    RMA_ENQUEUE_CONFIG = 0,         /**< Enqueue meta data to decoder, ex, SPS/PPS */
    RMA_ENQUEUE_FRAME = 1,          /**< Enqueue bitstream*/
    RMA_ENQUEUE_EOS = 2,            /**< Enqueue End of Serverice, decoder will stop working*/
} RMA_ENQUEUETYPE;

/**
 * Bitstream Format
 */
typedef enum {
    RMA_CODEC_MPEG4,
    RMA_CODEC_H264,
    RMA_CODEC_HEVC,
    RMA_CODEC_MPEG1,
    RMA_CODEC_MPEG2,
    RMA_CODEC_VP8,
    RMA_CODEC_VP9,
    RMA_CODEC_VC1,
    RMA_CODEC_WMV3,
    RMA_CODEC_UNSUPPORT1,
    RMA_CODEC_UNSUPPORT2,
    RMA_CODEC_UNSUPPORT3,
    RMA_CODEC_MJPEG,
    RMA_CODEC_H263,
    RMA_CODEC_AVS,
    RMA_CODEC_FLV,
    RMA_CODEC_AV1,
    RMA_CODEC_NONE,
} RMA_CODEC;

/**
 * Color Space of Output Frame, only RMA_COLOR_FORMAT_YUV420_SEMIPLANAR is vaild
 */
typedef enum {
    RMA_COLOR_FORMAT_YUV420_SEMIPLANAR,
    RMA_COLOR_FORMAT_YUV420_PLANAR,
    RMA_COLOR_FORMAT_NONE,
} RMA_COLOR_FORMAT;

typedef enum {
    RMA_VIDEO_AVC_PROFILE_BASELINE,
    RMA_VIDEO_AVC_PROFILE_CONSTRAINED_BASELINE,
    RMA_VIDEO_AVC_PROFILE_MAIN,
    RMA_VIDEO_AVC_PROFILE_EXTENTED,
    RMA_VIDEO_AVC_PROFILE_HIGH,
    RMA_VIDEO_AVC_PROFILE_HIGH_10,
    RMA_VIDEO_AVC_PROFILE_HIGH_10_INTRA,
    RMA_VIDEO_AVC_PROFILE_MULTIVIEW_HIGH,
    RMA_VIDEO_AVC_PROFILE_HIGH_422,
    RMA_VIDEO_AVC_PROFILE_HIGH_422_INTRA,
    RMA_VIDEO_AVC_PROFILE_STEREO_HIGH,
    RMA_VIDEO_AVC_PROFILE_HIGH_444,
    RMA_VIDEO_AVC_PROFILE_HIGH_444_PREDICTIVE,
    RMA_VIDEO_AVC_PROFILE_HIGH_444_INTRA,
    RMA_VIDEO_AVC_PROFILE_CAVLC_444,

    RMA_VIDEO_HEVC_PROFILE_MAIN,
    RMA_VIDEO_HEVC_PROFILE_MAIN_10,
    RMA_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE,
    RMA_VIDEO_HEVC_PROFILE_REXT,

    RMA_VIDEO_MPEG2_PROFILE_422,
    RMA_VIDEO_MPEG2_PROFILE_HIGH,
    RMA_VIDEO_MPEG2_PROFILE_SS,
    RMA_VIDEO_MPEG2_PROFILE_SNR_SCALABLE,
    RMA_VIDEO_MPEG2_PROFILE_MAIN,
    RMA_VIDEO_MPEG2_PROFILE_SIMPLE,

    RMA_VIDEO_MPEG4_PROFILE_SIMPLE,
    RMA_VIDEO_MPEG4_PROFILE_SIMPLE_SCALABLE,
    RMA_VIDEO_MPEG4_PROFILE_CORE,
    RMA_VIDEO_MPEG4_PROFILE_MAIN,
    RMA_VIDEO_MPEG4_PROFILE_N_BIT,
    RMA_VIDEO_MPEG4_PROFILE_SCALABLE_TEXTURE,
    RMA_VIDEO_MPEG4_PROFILE_SIMPLE_FACE_ANIMATION,
    RMA_VIDEO_MPEG4_PROFILE_BASIC_ANIMATED_TEXTURE,
    RMA_VIDEO_MPEG4_PROFILE_HYBRID,
    RMA_VIDEO_MPEG4_PROFILE_ADVANCED_REAL_TIME,
    RMA_VIDEO_MPEG4_PROFILE_CORE_SCALABLE,
    RMA_VIDEO_MPEG4_PROFILE_ADVANCED_CODING,
    RMA_VIDEO_MPEG4_PROFILE_ADVANCED_CORE,
    RMA_VIDEO_MPEG4_PROFILE_ADVANCED_SCALABLE_TEXTURE,
    RMA_VIDEO_MPEG4_PROFILE_SIMPLE_STUDIO,
    RMA_VIDEO_MPEG4_PROFILE_ADVANCED_SIMIPLE,

    RMA_VIDEO_WMV_PROFILE_SIMPLE,
    RMA_VIDEO_WMV_PROFILE_MAIN,
    RMA_VIDEO_WMV_PROFILE_COMPLEX,
    RMA_VIDEO_WMV_PROFILE_ADVANCED,

    RMA_VIDEO_VP9_PROFILE_0,
    RMA_VIDEO_VP9_PROFILE_1,
    RMA_VIDEO_VP9_PROFILE_2,
    RMA_VIDEO_VP9_PROFILE_2_HDR,

    RMA_VIDEO_PROFILE_UNKNOWN,
} RMA_MPEG2_PROFILE;
/**
 * Decode Frame Buffer Descriptor, 
 * the descriptor is filled by OMX and stored in the tail of each output frame
 */
typedef struct RMA_BUFFERINFO
{
    char buffer_id[4];              /**< Video Decoder Frame ID, if buffer_id={"R", "E", "A", "L"}, 
                                        the frame is generated by HW decoder, 
                                        otherwise the frame is generated by SW decoder*/
    unsigned char* pBuffer;            /**< Pointer to actual block of memory
                                     that is acting as the buffer */
    unsigned int nAllocLen;          /**< size of the buffer allocated, in bytes */
    unsigned int nFilledLen;         /**< number of bytes currently in the
                                     buffer */
    long long nTimeStamp;          /**< Timestamp corresponding to the sample
                                     starting at the first logical sample
                                     boundary in the buffer. Timestamps of
                                     successive samples within the buffer may
                                     be inferred by adding the duration of the
                                     of the preceding buffer to the timestamp
                                     of the preceding buffer.*/
    unsigned int phyBufAddr;
    unsigned int stride, plane_size;
    unsigned int width, height;
    void* bufferHeader;
    void* handler;
    unsigned int bufState;
} RMA_BUFFERINFO;

typedef struct RMA_OUTPUTINFO
{
    unsigned int width, height;
    unsigned int stride, plane_size;
    RMA_COLOR_FORMAT colorFmt;
} RMA_OUTPUTINFO;
/**
 * Decoder Parameters
 */
typedef struct RMA_PARAMETER
{
    RMA_CODEC codec;            /**< decoder format */
    unsigned int ori_width;     /**< original frame  width */
    unsigned int ori_height;    /**< original frame  height */
    unsigned int dec_o_width;   /**< resized frame width in output buffer*/
    unsigned int dec_o_height;  /**< resized frame height in output buffer*/
    unsigned int dec_o_fps;     /**< unused */
    unsigned int auto_resize;   /**< Respect the frame aspect to resize the output frame. OMX will keep the size of the long side of the output frame and overwrite the short side*/
    unsigned int turbo_mode;    /**< unused */
    unsigned int search_I_frm;  /**< unused */
    unsigned int search_I_err_tolerance;    /**< unused */
    unsigned int omx_version;   /**< return value, get the version of OMX library  */
    unsigned int renderFlg;     /**< unused */
    unsigned int dec_select;    /**< unused */
    int profile;                /**< bitstream profile */
    int level;                  /**< bitstream level */
    void *pUserData;            /**< unused */
    void (*setParam) (void *, RMA_COLOR_FORMAT, unsigned int, unsigned int);
} RMA_PARAMETER;

/**
 * @brief libRMA initial function, 
 * Enable a video decoder and return a handler if decoder is available
 *
 * @param[in] role A string to descript the selected video decoder,
 *              The available cases are "video_decoder.mpeg4", "video_decoder.vp9", "video_decoder.hevc", "video_decoder.avc"
 * @return Return a RMA Handler
 */
void* RMA_Init(const char * role);

/**
 * @brief libRMA deinitial function, 
 * Close a video decoder
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 */
void* RMA_Uninit(void *handler);

/**
 * @brief Start the selected video decoder
 * The return value is NULL
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 * @param[in] RMA_PARAMETER param the decoder control parameters
 */
RMA_ERRORTYPE RMA_Start(void *handler, RMA_PARAMETER param);

/**
 * @brief Free the output frame buffer
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 * @param[in] data buffer address of RMA_BUFFERINFO
 */
RMA_ERRORTYPE RMA_FreeBuffer(void *handler, void *data);

/**
 * @brief Enqueue bitstream data to decoder
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 * @param[in] data  bitstream data buffer address
 * @param[in] size bitstream data size
 * @param[in] timeStamp PTS timeStamp
 * @param[in] type      buffer data type
 */
RMA_ERRORTYPE RMA_EnqueueInputBuffer(void *handler, unsigned char *data, unsigned int size, long long timeStamp, RMA_ENQUEUETYPE type);

/**
 * @brief Dequeue a frame from decoder
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 * @param[in] outChange unused
 * @param[in] disp_buffer Decoder frame buffer descriptor
 * 
 */
RMA_ERRORTYPE RMA_DequeueOutputBuffer(void *handler, unsigned int *outChange, RMA_BUFFERINFO *disp_buffer);

/**
 * @brief Flush decoder
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 * 
 */
RMA_ERRORTYPE RMA_Flush(void *handler);

/**
 * @brief To check whether the frame buffer is from HW decoder or not
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 * @param[in] data  Frame buffer address
 * 
 */
RMA_ERRORTYPE RMA_CheckValidBuffer(void *handler, unsigned char *data);

/**
 * @brief Use DMA engine to copy memory, Only ion memory(continuous memory) is allow to use this function 
 *
 * @param[in] handler The RMA handler we get from RMA_Init()
 * @param[in] dst  destination memory address
 * @param[in] src  source memory address
 * @param[in] size data size
 * 
 */
RMA_ERRORTYPE RMA_Memcpy(void *handler, void *dst, void *src, unsigned int size);

#endif
